#!/bin/python3

import os
import sys
import pickle
import readline

from tasker import *

# location of data directory
data_dir = os.path.expanduser('~/Documents/todo/pickle_jar/')

# locations within todo directory
save_filepath = data_dir+'todo.pickle'
backup_filepath = data_dir+'backup.pickle'

# allow a few undo's by saving state in these files
undo_number = 5
undo_filepaths = [data_dir+'undo'+str(i)+'.pickle' for i in range(undo_number)]

############################################################################
#
#	contents
#
############################################################################

"""
contents
	this section, lists organization of this document

usage
	contains help-text describing usage

notes
	notes on the internal workings, useful for reading the code

execution
	point of contact with command line, top-level execution of code
"""


############################################################################
#
#	usage
#
############################################################################

help_text = """
todo - command line to-do list

usage:
    todo <command> <args>

commands and arguments:
<id> means a period-delimited list of numbers, e.g. 1.4.2
<name> means a string (quotes optional), e.g. check email

	list				pretty-print to-do list
		[-sub <id>]			only print specified task and subtasks

	add <name>			add a task
		[-sub <id>]			add as subtask of specified task
		[-top]				at at top of list (rather than default bottom)

	rm <id>				remove a task
	finish, remove, fin		aliases for rm
	
	rename <id> [<name>]	rename a task; if name is not specified,
							supplies current name for editing
		[-add]					append instead of replacing
	
	move <id>			move a task; requires one of the following:
		-into <id2>			make a subtask of <id2>
		-to <id2>			move to position <id2>
		-upto <int>			move up to rank <int> within parent
		-upby <int>			move up <int> ranks within parent
		-downto <int>		move down to rank <int> within parent
		-downby <int>		move down <int> ranks within parent

	fold <id>			fold a task, i.e. children are not printed
		[-all]				fold all top-level tasks

	unfold <id>			unfold a task
		[-all]				unfold all top-level tasks

	focus <id>			focus on specified task; equivalent to always
						including '-sub <id>' in commands that accept it

	unfocus				remove focus

	open <id>			equivalent to unfold + focus

	close				equivalent to fold (current focus task) + unfocus

	format <id> <str>	format a task with format <str>
						to see known formats, try it and the error will say
	
	full_upgrade		upgrade from a previous version (rarely needed)

universal arguments, can be passed with any command

	-verbose			re-throws errors that are normally handled by
						a chiding print statement
	
	-quiet				does not clear screen and re-print todo list
						
"""

# to print if save filepath is rejected
save_filepath_help = 'You can edit this script to change save_filepath to the desired location.'


############################################################################
#
#	notes
#
############################################################################

"""
Tasks are located by ID, a collection of numbers specifying subtask indices.
- IDs are displayed externally as period delimited strings indexing by 1,
	e.g. '1.4.2'
- IDs are used internally as lists of ints indexing by 0,
	e.g. [ 0, 3, 1 ]	(corresponding to '1.4.2' above).
- utilities ID_to_list and ID_to_str convert between them
- each task stores its own ID, which is updated whenever it may have changed

Arguments are read from command line into a dict (see parse_args utility)
- some are standalone flags, and are set to True if received
	e.g. 'todo list -verbose' results in { 'verbose' : True } in dict
- some are flags with parameters
	e.g. 'todo add -parent 1.4 ...' results in { 'parent' : '1.4' } in dict
- usually one argument is expected without a flag
	- depending on context, specifies name or ID of a task
	- called 'main' in dict
	e.g. 'todo add "email"' results in { 'main' : 'email' } in dict
Arguments are passed by dict unpacking
	e.g. 'todo add "email"'
		-> args = { 'main' : 'email" }
		-> todo_list.add(**args)
	thus class task_list methods generally take an argument 'main', which
		is renamed inside the method to clarify its role

Two main classes:
	class task holds basic task info and a small amount of functionality
		(just a couple functions that are defined recursively)
	class task_list accepts commands and manipulates tasks
		holds a root task which is the root of the task tree
"""


############################################################################
#
#	execution
#
############################################################################


# read command
if len(sys.argv) > 1:
	command = sys.argv[1]
# if no command, exit
else:
	#print(help_text)
	sys.exit()


# read arguments into a dict
try:
	args = parse_args(sys.argv[2:])
# may incur IndexError if command line arguments are incorrect
except IndexError as error:
	print('Error while parsing arguments. To check usage, run "todo -help".')
	sys.exit()

# check for universal flags and remove them from args
if 'verbose' in args and args['verbose']:
	verbose = True
	del args['verbose']
else:
	verbose = False
if 'quiet' in args and args['quiet']:
	quiet = True
	del args['quiet']
else:
	quiet = False

# if help flag is set to True, print help and exit
if 'help' in args and args['help']:
	print(help_text)
	sys.exit()


# read to-do list from file
try:
	todo_list = load_tasks(save_filepath)
# will incur AssertionError if file doesn't exist
#	and user declines to create it
except AssertionError as error:
	print(save_filepath_help)
	# if verbose is set to True, raise original error
	if verbose:
		raise error
	sys.exit()

# string describing changes made
description = False

# execute command
try:
	if command == 'add': description = todo_list.add(**args)
	elif command in ['rm','remove','forget','finish','fin']:
		description = todo_list.remove(**args)
	elif command == 'move': description = todo_list.move(**args)
	elif command in ['rename','edit']:
		description = todo_list.rename(**args)
	elif command == 'fold': description = todo_list.fold(**args)
	elif command == 'unfold': description = todo_list.unfold(**args)
	elif command == 'focus': description = todo_list.set_focus(**args)
	elif command == 'unfocus': description = todo_list.unset_focus(**args)
	elif command == 'open': description = todo_list.open_task(**args)
	elif command == 'close': description = todo_list.close_task(**args)
	elif command == 'update': description = todo_list.update_IDs()
	elif command == 'format': description = todo_list.format_task(**args)
	elif command == 'full_upgrade': description = todo_list.full_upgrade()
	# special commands that don't fall through to save and print
	elif command == 'backup':
		save_tasks(todo_list, backup_filepath)
		print('backed up.')
		sys.exit()
	elif command == 'list':
		# clear screen and list without saving
		clear_screen()
		print(todo_list.ls(**args))
		sys.exit()
	elif command == 'undo':
		undo_list = undo(save_filepath, undo_filepaths)
		if undo_list and not quiet:
			clear_screen()
			print(undo_list.ls())
		sys.exit()
	else:
		print('command "'+command+'" not recognized. To check usage, run "todo -help".')
		sys.exit()
	
	if not quiet:
		# clear screen and print
		clear_screen()
		print(todo_list.ls())
	# print description if there's anything to say
	if description:
		# if we just printed the todo list, add a newline, if not then not
		if not quiet:
			print()
		print(description.strip())
	save_tasks(todo_list, save_filepath, undo_filepaths)

# some methods throw AssertionError if they're unhappy
except AssertionError as error:
	print(error.args[0])
	if verbose:
		raise error
# may incur TypeError if arguments are incorrect
except TypeError as error:
	print('Error passing arguments to "'+command+'". To check usage, run "todo -help".')
	# if verbose is set to True, raise original error message
	if verbose:
		raise error



